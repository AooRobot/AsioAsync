是一个异步高并发的库工程项目
主要包含 Share Course 两个重要文件夹

Share:(共享)
  io_service_pool类
    主要创建一个 io_service组 用来管理异步通信工具
    创建一个 io_service::work组 用来保证io_service没有任务的时候也可以正常运作
    主要思想是通过io_service_pool的轮询来得到一个可用的io_service
	轮询:通过一个静态变量，每次被调用后自增
    功能接口:
    启动线程池
    停止线程池

  job_queue类:
    实现了一个线程安全的对列容器  safe_queue
    用到的组件:锁(mutex) 一个互斥体的锁
    实现的接口 push() , pop()  ---就是生产者消费者模型
  * 通过condition 条件 --通知一次  调用接口notify_one
		      与wait的搭配使用,可以快速解锁
		      这样其他线程就可以迅速向容器里填充数据
    
    线程安全的容器:
         safe_atom      (原子锁)  ----->原理汇编F3机器码，翻译为lock锁
   	 safe_vector    (线程安全的容器)  凡是修改动作用的是写锁,凡是访问
					  都是读锁
	 剩下的safe_list,safe_map   github中有大量代码，用到了知道去哪找

   scheduler计划(任务,每隔多长时间就执行一次调度):
      用线程安装回调函数
      间隔一定时间,执行一下回调函数
      比如心跳包(保活机制)的发送可以用它来制定周期执行

   tcp_message(包含了消息包头,包身的处理方法):
      用到boost::array的数组,一个用来装包头的内容,一个用来装包身内容
      提供了生成CRC校验和与检验CRC功能
	防止封包内容被别人篡改,一旦修改,这个数值就不一样了

   tcp_session(连接会话):
      代表每个客户端,继承自enable_shared_from_this 增加指示计数
      防止shared_ptr被析构,也就是让异步过程增加对智能指针的持有(use_count)计数器数值
      当没人用了,客户端就会被自动析构

【如果问：为什么要用智能指针来管理客户端
【答：因为我们不知道什么时候客户端会掉线，掉线了，异步过程就停止了，
    过程停止，引用计数自然无法继续增加持有，所以就被析构了

    worker(线程池):
	线程池就是多个线程被一个容器进行管理,然后轮询分配任务，
	进行异步处理数据，由于是异步的多线程争夺资源,所以我们才会使用线程安全的容器

//----------------------------------------------------------------------------------
Course:(网络通信用)  ：英文意思是流
   net_common构建的是：接收消息队列  request_queue    普通队列
		     发送消息队列  responce_queue
   构建了几个虚函数接口:   
      connected   连接成功
      disconnected  断开连接
      packeted    收到封包
      以上都是【虚函数】:
	子类有就用子类的，子类没有就用父类的
      
      【如果问：实现原理是什么
      【答：由于生成对象的时候，一定会先构造父类，由于有虚函数的对象
          内存头4字节是虚表指针，进去之后就是虚函数表
          虚函数排布顺序就是CPP文件中，虚函数书写顺序
	  总顺序排在前面的都是父类的虚函数，然后才是子类的虚函数

	  原理：是因为子类一定包含了父类内存空间，所以父类可以通过虚函数
		来提供接口

	【是怎么学习到这个知识呢】
	通过OD找到这个对象，去看了内存空间
	通过内联汇编_asm写一些花指令mov eax，eax
	快速定位代码，对象是通过构造函数返回的
	由于函数是通过EAX寄存器携带返回结果，
	可以去看eax寄存器的内存地址

     packet_factory包工厂：
	使用一个内存池：<boost/pool/object_pool.hpp>
	生成一个包对象,然后进行数据序列化   (整编)
	与数据反序列化  (解整编)
	
	问：序列化是什么
	利用boost库中的serialization 方法
 	具体方法是浸入式序列化，定义一个iarchive和oarchive
	并把serialization::access类设置为友元
	
	protocol buffer  是google开源的一个用于数据序列化的项目

	友元---女朋友类，虽然会破坏类的封装，但是可以用来解耦（依赖关系）
	也就是说，这个类可以访问调用者类的所有成员变量与方法
 
//----------------------------------------------------------------------------------
只需要提供一些回调函数就可以很方便的启动一个网络连接
   实现packeted垒中的那些虚函数方法，
   主要用来接管连接成功，断开方法，封包具体应该怎么处理